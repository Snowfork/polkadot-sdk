diff --git a/bridges/snowbridge/.gitignore b/bridges/snowbridge/.gitignore
new file mode 100644
index 00000000000..2c1d07caf6f
--- /dev/null
+++ b/bridges/snowbridge/.gitignore
@@ -0,0 +1,17 @@
+# Generated by Cargo
+# will have compiled files and executables
+**/target/
+# These are backup files generated by rustfmt
+**/*.rs.bk
+
+*.log
+rococo-local-raw.json
+rococo-local.json
+
+.envrc
+
+# The cache for chain data in container
+.local
+
+# coverage reports
+cobertura.xml
diff --git a/bridges/snowbridge/Cargo.toml b/bridges/snowbridge/Cargo.toml
new file mode 100644
index 00000000000..a9e9ed9abf9
--- /dev/null
+++ b/bridges/snowbridge/Cargo.toml
@@ -0,0 +1,54 @@
+[workspace.package]
+authors = ["Snowfork <contact@snowfork.com>"]
+edition = "2021"
+repository = "https://github.com/snowfork/polkadot-sdk.git"
+
+[workspace]
+resolver = "2"
+members = [
+	"pallets/ethereum-client",
+	"pallets/ethereum-client/fixtures",
+	"pallets/inbound-queue",
+	"pallets/inbound-queue/fixtures",
+	"pallets/outbound-queue",
+	"pallets/outbound-queue/merkle-tree",
+	"pallets/outbound-queue/runtime-api",
+	"pallets/system",
+	"pallets/system/runtime-api",
+	"primitives/beacon",
+	"primitives/core",
+	"primitives/ethereum",
+	"primitives/router",
+	"runtime/runtime-common",
+	"runtime/test-common",
+]
+
+
+[workspace.lints.rust]
+suspicious_double_ref_op = { level = "allow", priority = 2 }
+
+[workspace.lints.clippy]
+all = { level = "allow", priority = 0 }
+correctness = { level = "warn", priority = 1 }
+complexity = { level = "warn", priority = 1 }
+if-same-then-else = { level = "allow", priority = 2 }
+zero-prefixed-literal = { level = "allow", priority = 2 }            # 00_1000_000
+type_complexity = { level = "allow", priority = 2 }                  # raison d'etre
+nonminimal-bool = { level = "allow", priority = 2 }                  # maybe
+borrowed-box = { level = "allow", priority = 2 }                     # Reasonable to fix this one
+too-many-arguments = { level = "allow", priority = 2 }               # (Turning this on would lead to)
+needless-lifetimes = { level = "allow", priority = 2 }               # generated code
+unnecessary_cast = { level = "allow", priority = 2 }                 # Types may change
+identity-op = { level = "allow", priority = 2 }                      # One case where we do 0 +
+useless_conversion = { level = "allow", priority = 2 }               # Types may change
+unit_arg = { level = "allow", priority = 2 }                         # stylistic
+option-map-unit-fn = { level = "allow", priority = 2 }               # stylistic
+bind_instead_of_map = { level = "allow", priority = 2 }              # stylistic
+erasing_op = { level = "allow", priority = 2 }                       # E.g. 0 * DOLLARS
+eq_op = { level = "allow", priority = 2 }                            # In tests we test equality.
+while_immutable_condition = { level = "allow", priority = 2 }        # false positives
+needless_option_as_deref = { level = "allow", priority = 2 }         # false positives
+derivable_impls = { level = "allow", priority = 2 }                  # false positives
+stable_sort_primitive = { level = "allow", priority = 2 }            # prefer stable sort
+extra-unused-type-parameters = { level = "allow", priority = 2 }     # stylistic
+default_constructed_unit_structs = { level = "allow", priority = 2 } # stylistic
diff --git a/bridges/snowbridge/README.md b/bridges/snowbridge/README.md
index 49b9c2eaf55..3e5f63098ac 100644
--- a/bridges/snowbridge/README.md
+++ b/bridges/snowbridge/README.md
@@ -1,32 +1,40 @@
-# Snowbridge
-[![codecov](https://codecov.io/gh/Snowfork/snowbridge/branch/main/graph/badge.svg?token=9hvgSws4rN)](https://codecov.io/gh/Snowfork/snowbridge)
+# Snowbridge &middot;
+[![codecov](https://codecov.io/gh/Snowfork/polkadot-sdk/branch/snowbridge/graph/badge.svg?token=9hvgSws4rN)](https://codecov.io/gh/Snowfork/polkadot-sdk)
 ![GitHub](https://img.shields.io/github/license/Snowfork/snowbridge)
 
 Snowbridge is a trustless bridge between Polkadot and Ethereum. For documentation, visit https://docs.snowbridge.network.
 
 ## Components
 
+The Snowbridge project lives in two repositories:
+
+- [Snowfork/polkadot-sdk](https://github.com/Snowfork/polkadot-sdk): The Snowbridge parachain and pallets live in 
+a fork of the polkadot-sdk. Changes are eventually contributed back to
+[paritytech/polkadot-sdk](https://github.com/paritytech/polkadot-sdk)
+- [Snowfork/snowbridge](https://github.com/Snowfork/snowbridge): The rest of the Snowbridge components, like contracts,
+off-chain relayer, end-to-end tests and test-net setup code.
+
 ### Parachain
 
-Polkadot parachain and our pallets. See [parachain/README.md](https://github.com/Snowfork/snowbridge/blob/main/parachain/README.md).
+Polkadot parachain and our pallets. See [README.md](https://github.com/Snowfork/polkadot-sdk/blob/snowbridge/bridges/snowbridge/README.md).
 
 ### Contracts
 
-Ethereum contracts and unit tests. See [contracts/README.md](https://github.com/Snowfork/snowbridge/blob/main/contracts/README.md)
+Ethereum contracts and unit tests. See [Snowfork/snowbridge/contracts/README.md](https://github.com/Snowfork/snowbridge/blob/main/contracts/README.md)
 
 ### Relayer
 
 Off-chain relayer services for relaying messages between Polkadot and Ethereum. See
-[relayer/README.md](https://github.com/Snowfork/snowbridge/blob/main/relayer/README.md)
+[Snowfork/snowbridge/relayer/README.md](https://github.com/Snowfork/snowbridge/blob/main/relayer/README.md)
 
 ### Local Testnet
 
 Scripts to provision a local testnet, running the above services to bridge between local deployments of Polkadot and
-Ethereum. See [web/packages/test/README.md](https://github.com/Snowfork/snowbridge/blob/main/web/packages/test/README.md).
+Ethereum. See [Snowfork/snowbridge/web/packages/test/README.md](https://github.com/Snowfork/snowbridge/blob/main/web/packages/test/README.md).
 
 ### Smoke Tests
 
-Integration tests for our local testnet. See [smoketest/README.md](https://github.com/Snowfork/snowbridge/blob/main/smoketest/README.md).
+Integration tests for our local testnet. See [Snowfork/snowbridge/smoketest/README.md](https://github.com/Snowfork/snowbridge/blob/main/smoketest/README.md).
 
 ## Development
 
@@ -83,7 +91,7 @@ direnv allow
 
 ### Upgrading the Rust toolchain
 
-Sometimes we would like to upgrade rust toolchain. First update `parachain/rust-toolchain.toml` as required and then
+Sometimes we would like to upgrade rust toolchain. First update `rust-toolchain.toml` as required and then
 update `flake.lock` running
 ```sh
 nix flake lock --update-input rust-overlay
diff --git a/bridges/snowbridge/pallets/ethereum-client/Cargo.toml b/bridges/snowbridge/pallets/ethereum-client/Cargo.toml
index 2f76d5b8357..a30cb88c908 100644
--- a/bridges/snowbridge/pallets/ethereum-client/Cargo.toml
+++ b/bridges/snowbridge/pallets/ethereum-client/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-pallet-ethereum-client"
 description = "Snowbridge Ethereum Client Pallet"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/.gitignore b/bridges/snowbridge/pallets/ethereum-client/fuzz/.gitignore
new file mode 100644
index 00000000000..2f940cc8b2e
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/.gitignore
@@ -0,0 +1,5 @@
+target
+corpus
+artifacts
+coverage
+.idea
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/Cargo.toml b/bridges/snowbridge/pallets/ethereum-client/fuzz/Cargo.toml
new file mode 100644
index 00000000000..2a4e91590c2
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/Cargo.toml
@@ -0,0 +1,41 @@
+[package]
+name = "snowbridge-ethereum-client-fuzz"
+version = "0.0.0"
+publish = false
+edition = "2021"
+
+[package.metadata]
+cargo-fuzz = true
+
+[dependencies]
+libfuzzer-sys = { version = "0.4", features = ["arbitrary-derive"] }
+arbitrary = { version = "1", optional = true, features = ["derive"] }
+snowbridge-pallet-ethereum-client = { path = "..", features = ["fuzzing"] }
+snowbridge-beacon-primitives = { path = "../../../primitives/beacon" }
+hex-literal = "0.4.1"
+sp-core = { path = "../../../../../substrate/primitives/core", default-features = false }
+
+# Prevent this from interfering with workspaces
+[workspace]
+members = ["."]
+
+[profile.release]
+debug = 1
+
+[[bin]]
+name = "fuzz_force_checkpoint"
+path = "fuzz_targets/fuzz_force_checkpoint.rs"
+test = false
+doc = false
+
+[[bin]]
+name = "fuzz_submit"
+path = "fuzz_targets/fuzz_submit.rs"
+test = false
+doc = false
+
+[[bin]]
+name = "fuzz_submit_execution_header"
+path = "fuzz_targets/fuzz_submit_execution_header.rs"
+test = false
+doc = false
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/README.md b/bridges/snowbridge/pallets/ethereum-client/fuzz/README.md
new file mode 100644
index 00000000000..eeecf199ca0
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/README.md
@@ -0,0 +1,21 @@
+# Beacon client fuzz tests
+
+This crate contains fuzz tests for the three beacon client extrinsics.
+
+# Installation
+
+```
+cargo install cargo-fuzz
+```
+
+# Run tests
+
+- Force Checkpoint: `cargo fuzz run fuzz_force_checkpoint -- -max_len=10000000000`
+- Submit: `cargo fuzz run fuzz_submit -- -max_len=10000000000`
+- Submit Execution Header: `cargo fuzz run fuzz_submit_execution_header -- -max_len=10000000000`
+
+Note: `max-len` is necessary because the max input length is 4096 bytes. Some of our inputs are larger than this
+default value. When running the tests without an increased max len parameter, no fuzz data will be generated.
+
+The tests will keep running until a crash is found, so in our CI setup the number of runs is limited so that the
+test completes.
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_force_checkpoint.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_force_checkpoint.rs
new file mode 100644
index 00000000000..2e3d7543f46
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_force_checkpoint.rs
@@ -0,0 +1,16 @@
+#![no_main]
+extern crate snowbridge_pallet_ethereum_client;
+
+use libfuzzer_sys::fuzz_target;
+use snowbridge_pallet_ethereum_client::{mock::*, types::CheckpointUpdate};
+use snowbridge_ethereum_beacon_client_fuzz::types::FuzzCheckpointUpdate;
+use std::convert::TryInto;
+
+fuzz_target!(|input: FuzzCheckpointUpdate| {
+	new_tester().execute_with(|| {
+		let update: CheckpointUpdate = input.try_into().unwrap();
+		let result =
+			EthereumBeaconClient::force_checkpoint(RuntimeOrigin::root(), Box::new(update));
+		assert!(result.is_err());
+	});
+});
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit.rs
new file mode 100644
index 00000000000..79c69e2cb23
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit.rs
@@ -0,0 +1,16 @@
+#![no_main]
+extern crate snowbridge_pallet_ethereum_client;
+
+use snowbridge_pallet_ethereum_client::{mock::*, types::Update};
+use snowbridge_ethereum_beacon_client_fuzz::types::FuzzUpdate;
+use std::convert::TryInto;
+
+use libfuzzer_sys::fuzz_target;
+
+fuzz_target!(|input: FuzzUpdate| {
+	new_tester().execute_with(|| {
+		let update: Update = input.try_into().unwrap();
+		let result = EthereumBeaconClient::submit(RuntimeOrigin::signed(1), Box::new(update));
+		assert!(result.is_err());
+	});
+});
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit_execution_header.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit_execution_header.rs
new file mode 100644
index 00000000000..82f4ea97079
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/fuzz_targets/fuzz_submit_execution_header.rs
@@ -0,0 +1,19 @@
+#![no_main]
+extern crate snowbridge_pallet_ethereum_client;
+
+use snowbridge_beacon_primitives::ExecutionHeaderUpdate;
+use snowbridge_pallet_ethereum_client::mock::*;
+use snowbridge_pallet_ethereum_client::types::FuzzExecutionHeaderUpdate;
+
+use libfuzzer_sys::fuzz_target;
+
+fuzz_target!(|input: FuzzExecutionHeaderUpdate| {
+	new_tester().execute_with(|| {
+		let update: ExecutionHeaderUpdate = input.try_into().unwrap();
+		let result = EthereumBeaconClient::submit_execution_header(
+			RuntimeOrigin::signed(1),
+			Box::new(update),
+		);
+		assert!(result.is_err());
+	});
+});
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/src/impls.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/impls.rs
new file mode 100644
index 00000000000..b216429fd3c
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/impls.rs
@@ -0,0 +1,220 @@
+use crate::types::{
+	FuzzAncestryProof, FuzzBeaconHeader, FuzzCheckpointUpdate, FuzzExecutionHeaderUpdate,
+	FuzzExecutionPayloadHeader, FuzzNextSyncCommitteeUpdate, FuzzSyncAggregate, FuzzSyncCommittee,
+	FuzzUpdate,
+};
+use arbitrary::{Arbitrary, Result, Unstructured};
+use libfuzzer_sys::arbitrary;
+use snowbridge_beacon_primitives::{
+	types::BeaconHeader, updates::AncestryProof, ExecutionHeaderUpdate, ExecutionPayloadHeader,
+	PublicKey,
+};
+use snowbridge_pallet_ethereum_client::types::{
+	CheckpointUpdate, NextSyncCommitteeUpdate, SyncAggregate, SyncCommittee, Update,
+};
+use sp_core::H256;
+use std::convert::TryInto;
+
+impl TryFrom<FuzzUpdate> for Update {
+	type Error = String;
+
+	fn try_from(other: FuzzUpdate) -> Result<Self, Self::Error> {
+		let next: Option<NextSyncCommitteeUpdate> = other
+			.next_sync_committee_update
+			.map(|fuzz_update| fuzz_update.try_into().unwrap());
+
+		Ok(Self {
+			attested_header: other.attested_header.clone().try_into().unwrap(),
+			sync_aggregate: other.sync_aggregate.try_into().unwrap(),
+			signature_slot: other.signature_slot,
+			next_sync_committee_update: next,
+			finalized_header: other.finalized_header.clone().try_into().unwrap(),
+			finality_branch: other
+				.finality_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+			block_roots_root: other.block_roots_root.into(),
+			block_roots_branch: other
+				.block_roots_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+		})
+	}
+}
+
+impl TryFrom<FuzzNextSyncCommitteeUpdate> for NextSyncCommitteeUpdate {
+	type Error = String;
+
+	fn try_from(other: FuzzNextSyncCommitteeUpdate) -> Result<Self, Self::Error> {
+		Ok(Self {
+			next_sync_committee: other.next_sync_committee.try_into().unwrap(),
+			next_sync_committee_branch: other
+				.next_sync_committee_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+		})
+	}
+}
+
+impl TryFrom<FuzzSyncAggregate> for SyncAggregate {
+	type Error = String;
+
+	fn try_from(other: FuzzSyncAggregate) -> Result<Self, Self::Error> {
+		Ok(Self {
+			sync_committee_bits: other.sync_committee_bits.into(),
+			sync_committee_signature: other.sync_committee_signature.into(),
+		})
+	}
+}
+
+impl TryFrom<FuzzCheckpointUpdate> for CheckpointUpdate {
+	type Error = String;
+
+	fn try_from(other: FuzzCheckpointUpdate) -> Result<Self, Self::Error> {
+		Ok(Self {
+			header: other.header.clone().try_into().unwrap(),
+			current_sync_committee: other.current_sync_committee.try_into().unwrap(),
+			current_sync_committee_branch: other
+				.current_sync_committee_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+			validators_root: other.validators_root.into(),
+			block_roots_root: other.block_roots_root.into(),
+			block_roots_branch: other
+				.block_roots_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+		})
+	}
+}
+
+impl TryFrom<FuzzSyncCommittee> for SyncCommittee {
+	type Error = String;
+
+	fn try_from(other: FuzzSyncCommittee) -> Result<Self, Self::Error> {
+		Ok(Self {
+			pubkeys: other
+				.pubkeys
+				.iter()
+				.map(|&pk| { pk.into() })
+				.collect::<Vec<PublicKey>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+			aggregate_pubkey: other.aggregate_pubkey.into(),
+		})
+	}
+}
+
+impl TryFrom<FuzzAncestryProof> for AncestryProof {
+	type Error = String;
+
+	fn try_from(other: FuzzAncestryProof) -> Result<Self, Self::Error> {
+		Ok(Self {
+			header_branch: other
+				.header_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+			finalized_block_root: other.finalized_block_root.into(),
+		})
+	}
+}
+
+impl TryFrom<FuzzExecutionPayloadHeader> for ExecutionPayloadHeader {
+	type Error = String;
+
+	fn try_from(other: FuzzExecutionPayloadHeader) -> Result<Self, Self::Error> {
+		Ok(Self {
+			parent_hash: other.parent_hash.into(),
+			fee_recipient: other.fee_recipient.into(),
+			state_root: other.state_root.into(),
+			receipts_root: other.receipts_root.into(),
+			logs_bloom: other.logs_bloom.into(),
+			prev_randao: other.prev_randao.into(),
+			block_number: other.block_number,
+			gas_limit: other.gas_limit,
+			gas_used: other.gas_used,
+			timestamp: other.timestamp,
+			extra_data: other.extra_data.into(),
+			base_fee_per_gas: other.base_fee_per_gas.into(),
+			block_hash: other.block_hash.into(),
+			transactions_root: other.transactions_root.into(),
+			withdrawals_root: other.withdrawals_root.into(),
+		})
+	}
+}
+
+impl TryFrom<FuzzBeaconHeader> for BeaconHeader {
+	type Error = String;
+
+	fn try_from(other: FuzzBeaconHeader) -> Result<Self, Self::Error> {
+		Ok(Self {
+			slot: other.slot,
+			proposer_index: other.proposer_index,
+			parent_root: other.parent_root.into(),
+			state_root: other.state_root.into(),
+			body_root: other.body_root.into(),
+		})
+	}
+}
+
+impl TryFrom<FuzzExecutionHeaderUpdate> for ExecutionHeaderUpdate {
+	type Error = String;
+
+	fn try_from(other: FuzzExecutionHeaderUpdate) -> Result<Self, Self::Error> {
+		let ancestry_proof: Option<AncestryProof> =
+			other.ancestry_proof.map(|fuzz_update| fuzz_update.try_into().unwrap());
+
+		Ok(Self {
+			header: other.header.try_into().unwrap(),
+			ancestry_proof,
+			execution_header: other.execution_header.try_into().unwrap(),
+			execution_branch: other
+				.execution_branch
+				.iter()
+				.map(|&hash| H256::from(hash))
+				.collect::<Vec<_>>()
+				.as_slice()
+				.try_into()
+				.unwrap(),
+		})
+	}
+}
+
+// The arbitrary derive implementation is super slow for the pubkey set, so create a custom
+// impl for the sync committee.
+impl Arbitrary<'_> for FuzzSyncCommittee {
+	fn arbitrary(u: &mut Unstructured<'_>) -> Result<Self> {
+		let mut pubkeys = [[0u8; 48]; 32];
+
+		for i in 0..32 {
+			pubkeys[i] = <[u8; 48]>::arbitrary(u)?;
+		}
+
+		Ok(FuzzSyncCommittee { pubkeys, aggregate_pubkey: <[u8; 48]>::arbitrary(u)? })
+	}
+}
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/src/lib.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/lib.rs
new file mode 100644
index 00000000000..fb880c01820
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/lib.rs
@@ -0,0 +1,2 @@
+pub mod impls;
+pub mod types;
diff --git a/bridges/snowbridge/pallets/ethereum-client/fuzz/src/types.rs b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/types.rs
new file mode 100644
index 00000000000..37e5eb0d6c4
--- /dev/null
+++ b/bridges/snowbridge/pallets/ethereum-client/fuzz/src/types.rs
@@ -0,0 +1,83 @@
+use libfuzzer_sys::arbitrary;
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzCheckpointUpdate {
+	pub header: FuzzBeaconHeader,
+	pub current_sync_committee: FuzzSyncCommittee,
+	pub current_sync_committee_branch: Vec<[u8; 32]>,
+	pub validators_root: [u8; 32],
+	pub block_roots_root: [u8; 32],
+	pub block_roots_branch: Vec<[u8; 32]>,
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzBeaconHeader {
+	pub slot: u64,
+	pub proposer_index: u64,
+	pub parent_root: [u8; 32],
+	pub state_root: [u8; 32],
+	pub body_root: [u8; 32],
+}
+
+#[derive(Debug, Clone)]
+pub struct FuzzSyncCommittee {
+	pub pubkeys: [[u8; 48]; 32],
+	pub aggregate_pubkey: [u8; 48],
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzUpdate {
+	pub attested_header: FuzzBeaconHeader,
+	pub sync_aggregate: FuzzSyncAggregate,
+	pub signature_slot: u64,
+	pub next_sync_committee_update: Option<FuzzNextSyncCommitteeUpdate>,
+	pub finalized_header: FuzzBeaconHeader,
+	pub finality_branch: Vec<[u8; 32]>,
+	pub block_roots_root: [u8; 32],
+	pub block_roots_branch: Vec<[u8; 32]>,
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzSyncAggregate {
+	pub sync_committee_bits: [u8; 4],
+	pub sync_committee_signature: [u8; 96],
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzNextSyncCommitteeUpdate {
+	pub next_sync_committee: FuzzSyncCommittee,
+	pub next_sync_committee_branch: Vec<[u8; 32]>,
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzExecutionHeaderUpdate {
+	pub header: FuzzBeaconHeader,
+	pub ancestry_proof: Option<FuzzAncestryProof>,
+	pub execution_header: FuzzExecutionPayloadHeader,
+	pub execution_branch: Vec<[u8; 32]>,
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzAncestryProof {
+	pub header_branch: Vec<[u8; 32]>,
+	pub finalized_block_root: [u8; 32],
+}
+
+#[derive(arbitrary::Arbitrary, Debug, Clone)]
+pub struct FuzzExecutionPayloadHeader {
+	pub parent_hash: [u8; 32],
+	pub fee_recipient: [u8; 20],
+	pub state_root: [u8; 32],
+	pub receipts_root: [u8; 32],
+	pub logs_bloom: Vec<u8>,
+	pub prev_randao: [u8; 32],
+	pub block_number: u64,
+	pub gas_limit: u64,
+	pub gas_used: u64,
+	pub timestamp: u64,
+	pub extra_data: Vec<u8>,
+	pub base_fee_per_gas: [u8; 32],
+	pub block_hash: [u8; 32],
+	pub transactions_root: [u8; 32],
+	pub withdrawals_root: [u8; 32],
+}
diff --git a/bridges/snowbridge/pallets/inbound-queue/Cargo.toml b/bridges/snowbridge/pallets/inbound-queue/Cargo.toml
index 1081b162dda..dc853dc0a51 100644
--- a/bridges/snowbridge/pallets/inbound-queue/Cargo.toml
+++ b/bridges/snowbridge/pallets/inbound-queue/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-pallet-inbound-queue"
 description = "Snowbridge Inbound Queue Pallet"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/inbound-queue/src/mock.rs b/bridges/snowbridge/pallets/inbound-queue/src/mock.rs
index 110f611c676..d75c3c6a186 100644
--- a/bridges/snowbridge/pallets/inbound-queue/src/mock.rs
+++ b/bridges/snowbridge/pallets/inbound-queue/src/mock.rs
@@ -88,6 +88,7 @@ impl pallet_balances::Config for Test {
 	type MaxFreezes = ();
 	type RuntimeHoldReason = ();
 	type RuntimeFreezeReason = ();
+	type MaxHolds = ();
 }
 
 parameter_types! {
diff --git a/bridges/snowbridge/pallets/outbound-queue/Cargo.toml b/bridges/snowbridge/pallets/outbound-queue/Cargo.toml
index ae52fb3e5c4..03ddb12b7b4 100644
--- a/bridges/snowbridge/pallets/outbound-queue/Cargo.toml
+++ b/bridges/snowbridge/pallets/outbound-queue/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-pallet-outbound-queue"
 description = "Snowbridge Outbound Queue Pallet"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/outbound-queue/merkle-tree/Cargo.toml b/bridges/snowbridge/pallets/outbound-queue/merkle-tree/Cargo.toml
index c185d5af706..503dc14bbc9 100644
--- a/bridges/snowbridge/pallets/outbound-queue/merkle-tree/Cargo.toml
+++ b/bridges/snowbridge/pallets/outbound-queue/merkle-tree/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-outbound-queue-merkle-tree"
 description = "Snowbridge Outbound Queue Merkle Tree"
-version = "0.1.1"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/outbound-queue/runtime-api/Cargo.toml b/bridges/snowbridge/pallets/outbound-queue/runtime-api/Cargo.toml
index 347b3bae493..0f0bfc4e358 100644
--- a/bridges/snowbridge/pallets/outbound-queue/runtime-api/Cargo.toml
+++ b/bridges/snowbridge/pallets/outbound-queue/runtime-api/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-outbound-queue-runtime-api"
 description = "Snowbridge Outbound Queue Runtime API"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/system/Cargo.toml b/bridges/snowbridge/pallets/system/Cargo.toml
index aa600511633..f365b52e84d 100644
--- a/bridges/snowbridge/pallets/system/Cargo.toml
+++ b/bridges/snowbridge/pallets/system/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-pallet-system"
 description = "Snowbridge System Pallet"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/system/runtime-api/Cargo.toml b/bridges/snowbridge/pallets/system/runtime-api/Cargo.toml
index 355d2d29147..6d3735f776b 100644
--- a/bridges/snowbridge/pallets/system/runtime-api/Cargo.toml
+++ b/bridges/snowbridge/pallets/system/runtime-api/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-system-runtime-api"
 description = "Snowbridge System Runtime API"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/pallets/system/src/lib.rs b/bridges/snowbridge/pallets/system/src/lib.rs
index b7f38fb753d..13abee14b4a 100644
--- a/bridges/snowbridge/pallets/system/src/lib.rs
+++ b/bridges/snowbridge/pallets/system/src/lib.rs
@@ -79,6 +79,8 @@ use xcm_executor::traits::ConvertLocation;
 #[cfg(feature = "runtime-benchmarks")]
 use frame_support::traits::OriginTrait;
 
+pub use pallet::*;
+
 pub type BalanceOf<T> =
 	<<T as pallet::Config>::Token as Inspect<<T as frame_system::Config>::AccountId>>::Balance;
 pub type AccountIdOf<T> = <T as frame_system::Config>::AccountId;
diff --git a/bridges/snowbridge/pallets/system/src/mock.rs b/bridges/snowbridge/pallets/system/src/mock.rs
index edc3f141b07..bc229578132 100644
--- a/bridges/snowbridge/pallets/system/src/mock.rs
+++ b/bridges/snowbridge/pallets/system/src/mock.rs
@@ -136,6 +136,7 @@ impl pallet_balances::Config for Test {
 	type MaxFreezes = ();
 	type RuntimeHoldReason = ();
 	type RuntimeFreezeReason = ();
+	type MaxHolds = ();
 }
 
 impl pallet_xcm_origin::Config for Test {
diff --git a/bridges/snowbridge/primitives/beacon/Cargo.toml b/bridges/snowbridge/primitives/beacon/Cargo.toml
index b59e5191b41..bb30eae33b1 100644
--- a/bridges/snowbridge/primitives/beacon/Cargo.toml
+++ b/bridges/snowbridge/primitives/beacon/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-beacon-primitives"
 description = "Snowbridge Beacon Primitives"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/primitives/beacon/src/types.rs b/bridges/snowbridge/primitives/beacon/src/types.rs
index 2af522f56b0..6f0886ba8b5 100644
--- a/bridges/snowbridge/primitives/beacon/src/types.rs
+++ b/bridges/snowbridge/primitives/beacon/src/types.rs
@@ -586,7 +586,7 @@ pub mod deneb {
 	use sp_std::prelude::*;
 
 	/// ExecutionPayloadHeader
-	/// <https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/beacon-chain.md#executionpayloadheader>
+	/// https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/beacon-chain.md#executionpayloadheader
 	#[derive(
 		Default, Encode, Decode, CloneNoBound, PartialEqNoBound, RuntimeDebugNoBound, TypeInfo,
 	)]
diff --git a/bridges/snowbridge/primitives/core/Cargo.toml b/bridges/snowbridge/primitives/core/Cargo.toml
index f735d01a848..8df3ac21f4b 100644
--- a/bridges/snowbridge/primitives/core/Cargo.toml
+++ b/bridges/snowbridge/primitives/core/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-core"
 description = "Snowbridge Core"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/primitives/ethereum/Cargo.toml b/bridges/snowbridge/primitives/ethereum/Cargo.toml
index 047ebdd5669..710a056daa5 100644
--- a/bridges/snowbridge/primitives/ethereum/Cargo.toml
+++ b/bridges/snowbridge/primitives/ethereum/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-ethereum"
 description = "Snowbridge Ethereum"
-version = "0.1.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/primitives/router/Cargo.toml b/bridges/snowbridge/primitives/router/Cargo.toml
index 712c60c2148..6c0d6aefed9 100644
--- a/bridges/snowbridge/primitives/router/Cargo.toml
+++ b/bridges/snowbridge/primitives/router/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-router-primitives"
 description = "Snowbridge Router Primitives"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/runtime/runtime-common/Cargo.toml b/bridges/snowbridge/runtime/runtime-common/Cargo.toml
index f5b44b25585..12f9cfa42d9 100644
--- a/bridges/snowbridge/runtime/runtime-common/Cargo.toml
+++ b/bridges/snowbridge/runtime/runtime-common/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-runtime-common"
 description = "Snowbridge Runtime Common"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition.workspace = true
 repository.workspace = true
diff --git a/bridges/snowbridge/runtime/test-common/Cargo.toml b/bridges/snowbridge/runtime/test-common/Cargo.toml
index a2994e61891..7c02ac40b63 100644
--- a/bridges/snowbridge/runtime/test-common/Cargo.toml
+++ b/bridges/snowbridge/runtime/test-common/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "snowbridge-runtime-test-common"
 description = "Snowbridge Runtime Tests"
-version = "0.0.0"
+version = "0.9.0"
 authors = ["Snowfork <contact@snowfork.com>"]
 edition = "2021"
 license = "Apache-2.0"
diff --git a/bridges/snowbridge/rustfmt.toml b/bridges/snowbridge/rustfmt.toml
new file mode 100644
index 00000000000..c3421539123
--- /dev/null
+++ b/bridges/snowbridge/rustfmt.toml
@@ -0,0 +1,24 @@
+# Basic
+edition = "2021"
+hard_tabs = true
+max_width = 100
+use_small_heuristics = "Max"
+# Imports
+imports_granularity = "Crate"
+reorder_imports = true
+# Consistency
+newline_style = "Unix"
+# Misc
+chain_width = 80
+spaces_around_ranges = false
+binop_separator = "Back"
+reorder_impl_items = false
+match_arm_leading_pipes = "Preserve"
+match_arm_blocks = false
+match_block_trailing_comma = true
+trailing_comma = "Vertical"
+trailing_semicolon = false
+use_field_init_shorthand = true
+# Format comments
+comment_width = 100
+wrap_comments = true
diff --git a/bridges/snowbridge/scripts/contribute-upstream.sh b/bridges/snowbridge/scripts/contribute-upstream.sh
new file mode 100755
index 00000000000..8aa2d2a7035
--- /dev/null
+++ b/bridges/snowbridge/scripts/contribute-upstream.sh
@@ -0,0 +1,80 @@
+#!/bin/bash
+
+# A script to cleanup the Snowfork fork of the polkadot-sdk to contribute it upstream back to parity/polkadot-sdk
+# ./bridges/snowbridge/scripts/contribute-upstream.sh <branchname>
+
+# show CLI help
+function show_help() {
+  set +x
+  echo " "
+  echo Error: $1
+  echo "Usage:"
+  echo "  ./bridges/snowbridge/scripts/contribute-upstream.sh <branchname>         Exit with code 0 if pallets code is well decoupled from the other code in the repo"
+  exit 1
+}
+
+if [[ -z "$1" ]]; then
+    echo "Please provide a branch name you would like your upstream branch to be named"
+    exit 1
+fi
+
+branch_name=$1
+
+set -eux
+
+# let's avoid any restrictions on where this script can be called for - snowbridge repo may be
+# plugged into any other repo folder. So the script (and other stuff that needs to be removed)
+# may be located either in call dir, or one of it subdirs.
+SNOWBRIDGE_FOLDER="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )/../"
+
+# Get the current Git branch name
+current_branch=$(git rev-parse --abbrev-ref HEAD)
+
+if [ "$current_branch" = "$branch_name" ] || git branch | grep -q "$branch_name"; then
+    echo "Already on requested branch or branch exists, not creating."
+else
+    git branch "$branch_name"
+fi
+
+git checkout "$branch_name"
+
+# remove everything we think is not required for our needs
+rm -rf rust-toolchain.toml
+rm -rf $SNOWBRIDGE_FOLDER/.cargo
+rm -rf $SNOWBRIDGE_FOLDER/.github
+rm -rf $SNOWBRIDGE_FOLDER/SECURITY.md
+rm -rf $SNOWBRIDGE_FOLDER/.gitignore
+rm -rf $SNOWBRIDGE_FOLDER/templates
+rm -rf $SNOWBRIDGE_FOLDER/pallets/ethereum-client/fuzz
+
+pushd $SNOWBRIDGE_FOLDER
+
+# let's test if everything we need compiles
+cargo check -p snowbridge-pallet-ethereum-client
+cargo check -p snowbridge-pallet-ethereum-client --features runtime-benchmarks
+cargo check -p snowbridge-pallet-ethereum-client --features try-runtime
+cargo check -p snowbridge-pallet-inbound-queue
+cargo check -p snowbridge-pallet-inbound-queue --features runtime-benchmarks
+cargo check -p snowbridge-pallet-inbound-queue --features try-runtime
+cargo check -p snowbridge-pallet-outbound-queue
+cargo check -p snowbridge-pallet-outbound-queue --features runtime-benchmarks
+cargo check -p snowbridge-pallet-outbound-queue --features try-runtime
+cargo check -p snowbridge-pallet-system
+cargo check -p snowbridge-pallet-system --features runtime-benchmarks
+cargo check -p snowbridge-pallet-system --features try-runtime
+
+# we're removing lock file after all checks are done. Otherwise we may use different
+# Substrate/Polkadot/Cumulus commits and our checks will fail
+rm -f $SNOWBRIDGE_FOLDER/Cargo.toml
+rm -f $SNOWBRIDGE_FOLDER/Cargo.lock
+
+popd
+
+# Replace Parity's CI files, that we have overwritten in our fork, to run our own CI
+rm -rf .github
+git remote -v | grep -w parity || git remote add parity https://github.com/paritytech/polkadot-sdk
+git fetch parity master
+git checkout parity/master -- .github
+git add -- .github
+
+echo "OK"
diff --git a/bridges/snowbridge/templates/benchmarking-fixtures.mustache b/bridges/snowbridge/templates/benchmarking-fixtures.mustache
new file mode 100644
index 00000000000..abeab79a532
--- /dev/null
+++ b/bridges/snowbridge/templates/benchmarking-fixtures.mustache
@@ -0,0 +1,179 @@
+// Generated, do not edit!
+// See README.md for instructions to generate
+use crate::{
+	CheckpointUpdate, ExecutionHeaderUpdate, Update,
+};
+use hex_literal::hex;
+use primitives::{
+    types::deneb, updates::AncestryProof, BeaconHeader, NextSyncCommitteeUpdate, SyncAggregate,
+    SyncCommittee, VersionedExecutionPayloadHeader,
+};
+use sp_core::U256;
+use sp_std::{boxed::Box, vec};
+
+pub fn make_checkpoint() -> Box<CheckpointUpdate> {
+    Box::new(CheckpointUpdate {
+        header: BeaconHeader {
+            slot: {{CheckpointUpdate.Header.Slot}},
+            proposer_index: {{CheckpointUpdate.Header.ProposerIndex}},
+            parent_root: hex!("{{CheckpointUpdate.Header.ParentRoot}}").into(),
+            state_root: hex!("{{CheckpointUpdate.Header.StateRoot}}").into(),
+            body_root: hex!("{{CheckpointUpdate.Header.BodyRoot}}").into(),
+        },
+        current_sync_committee: SyncCommittee {
+            pubkeys: [
+            {{#CheckpointUpdate.CurrentSyncCommittee.Pubkeys}}
+                hex!("{{.}}").into(),
+            {{/CheckpointUpdate.CurrentSyncCommittee.Pubkeys}}
+            ],
+            aggregate_pubkey: hex!("{{CheckpointUpdate.CurrentSyncCommittee.AggregatePubkey}}").into(),
+        },
+        current_sync_committee_branch: vec![
+            {{#CheckpointUpdate.CurrentSyncCommitteeBranch}}
+                hex!("{{.}}").into(),
+            {{/CheckpointUpdate.CurrentSyncCommitteeBranch}}
+        ],
+        validators_root: hex!("{{CheckpointUpdate.ValidatorsRoot}}").into(),
+        block_roots_root: hex!("{{CheckpointUpdate.BlockRootsRoot}}").into(),
+        block_roots_branch: vec![
+        {{#CheckpointUpdate.BlockRootsBranch}}
+            hex!("{{.}}").into(),
+        {{/CheckpointUpdate.BlockRootsBranch}}
+        ],
+    })
+}
+
+pub fn make_sync_committee_update() -> Box<Update> {
+    Box::new(Update {
+        attested_header: BeaconHeader {
+            slot: {{SyncCommitteeUpdate.AttestedHeader.Slot}},
+            proposer_index: {{SyncCommitteeUpdate.AttestedHeader.ProposerIndex}},
+            parent_root: hex!("{{SyncCommitteeUpdate.AttestedHeader.ParentRoot}}").into(),
+            state_root: hex!("{{SyncCommitteeUpdate.AttestedHeader.StateRoot}}").into(),
+            body_root: hex!("{{SyncCommitteeUpdate.AttestedHeader.BodyRoot}}").into(),
+        },
+        sync_aggregate: SyncAggregate{
+            sync_committee_bits: hex!("{{SyncCommitteeUpdate.SyncAggregate.SyncCommitteeBits}}"),
+            sync_committee_signature: hex!("{{SyncCommitteeUpdate.SyncAggregate.SyncCommitteeSignature}}").into(),
+        },
+        signature_slot: {{SyncCommitteeUpdate.SignatureSlot}},
+        next_sync_committee_update: Some(NextSyncCommitteeUpdate {
+            next_sync_committee: SyncCommittee {
+                pubkeys: [
+                {{#SyncCommitteeUpdate.NextSyncCommitteeUpdate.NextSyncCommittee.Pubkeys}}
+                    hex!("{{.}}").into(),
+                {{/SyncCommitteeUpdate.NextSyncCommitteeUpdate.NextSyncCommittee.Pubkeys}}
+                ],
+                aggregate_pubkey: hex!("{{SyncCommitteeUpdate.NextSyncCommitteeUpdate.NextSyncCommittee.AggregatePubkey}}").into(),
+            },
+            next_sync_committee_branch: vec![
+            {{#SyncCommitteeUpdate.NextSyncCommitteeUpdate.NextSyncCommitteeBranch}}
+                hex!("{{.}}").into(),
+            {{/SyncCommitteeUpdate.NextSyncCommitteeUpdate.NextSyncCommitteeBranch}}
+            ],
+        }),
+        finalized_header: BeaconHeader{
+            slot: {{SyncCommitteeUpdate.FinalizedHeader.Slot}},
+            proposer_index: {{SyncCommitteeUpdate.FinalizedHeader.ProposerIndex}},
+            parent_root: hex!("{{SyncCommitteeUpdate.FinalizedHeader.ParentRoot}}").into(),
+            state_root: hex!("{{SyncCommitteeUpdate.FinalizedHeader.StateRoot}}").into(),
+            body_root: hex!("{{SyncCommitteeUpdate.FinalizedHeader.BodyRoot}}").into(),
+        },
+        finality_branch: vec![
+        {{#SyncCommitteeUpdate.FinalityBranch}}
+            hex!("{{.}}").into(),
+        {{/SyncCommitteeUpdate.FinalityBranch}}
+        ],
+        block_roots_root: hex!("{{SyncCommitteeUpdate.BlockRootsRoot}}").into(),
+        block_roots_branch: vec![
+        {{#SyncCommitteeUpdate.BlockRootsBranch}}
+            hex!("{{.}}").into(),
+        {{/SyncCommitteeUpdate.BlockRootsBranch}}
+        ],
+    })
+}
+
+pub fn make_finalized_header_update() -> Box<Update> {
+    Box::new(Update {
+        attested_header: BeaconHeader {
+            slot: {{FinalizedHeaderUpdate.AttestedHeader.Slot}},
+            proposer_index: {{FinalizedHeaderUpdate.AttestedHeader.ProposerIndex}},
+            parent_root: hex!("{{FinalizedHeaderUpdate.AttestedHeader.ParentRoot}}").into(),
+            state_root: hex!("{{FinalizedHeaderUpdate.AttestedHeader.StateRoot}}").into(),
+            body_root: hex!("{{FinalizedHeaderUpdate.AttestedHeader.BodyRoot}}").into(),
+        },
+        sync_aggregate: SyncAggregate{
+            sync_committee_bits: hex!("{{FinalizedHeaderUpdate.SyncAggregate.SyncCommitteeBits}}"),
+            sync_committee_signature: hex!("{{FinalizedHeaderUpdate.SyncAggregate.SyncCommitteeSignature}}").into(),
+        },
+        signature_slot: {{FinalizedHeaderUpdate.SignatureSlot}},
+        next_sync_committee_update: None,
+        finalized_header: BeaconHeader {
+            slot: {{FinalizedHeaderUpdate.FinalizedHeader.Slot}},
+            proposer_index: {{FinalizedHeaderUpdate.FinalizedHeader.ProposerIndex}},
+            parent_root: hex!("{{FinalizedHeaderUpdate.FinalizedHeader.ParentRoot}}").into(),
+            state_root: hex!("{{FinalizedHeaderUpdate.FinalizedHeader.StateRoot}}").into(),
+            body_root: hex!("{{FinalizedHeaderUpdate.FinalizedHeader.BodyRoot}}").into(),
+        },
+        finality_branch: vec![
+        {{#FinalizedHeaderUpdate.FinalityBranch}}
+            hex!("{{.}}").into(),
+        {{/FinalizedHeaderUpdate.FinalityBranch}}
+        ],
+        block_roots_root: hex!("{{FinalizedHeaderUpdate.BlockRootsRoot}}").into(),
+        block_roots_branch: vec![
+        {{#FinalizedHeaderUpdate.BlockRootsBranch}}
+            hex!("{{.}}").into(),
+        {{/FinalizedHeaderUpdate.BlockRootsBranch}}
+        ]
+    })
+}
+
+pub fn make_execution_header_update() -> Box<ExecutionHeaderUpdate> {
+    Box::new(ExecutionHeaderUpdate {
+        header: BeaconHeader {
+            slot: {{HeaderUpdate.Header.Slot}},
+            proposer_index: {{HeaderUpdate.Header.ProposerIndex}},
+            parent_root: hex!("{{HeaderUpdate.Header.ParentRoot}}").into(),
+            state_root: hex!("{{HeaderUpdate.Header.StateRoot}}").into(),
+            body_root: hex!("{{HeaderUpdate.Header.BodyRoot}}").into(),
+        },
+        {{#HeaderUpdate.AncestryProof}}
+        ancestry_proof: Some(AncestryProof {
+            header_branch: vec![
+            {{#HeaderUpdate.AncestryProof.HeaderBranch}}
+                hex!("{{.}}").into(),
+            {{/HeaderUpdate.AncestryProof.HeaderBranch}}
+            ],
+            finalized_block_root: hex!("{{HeaderUpdate.AncestryProof.FinalizedBlockRoot}}").into(),
+        }),
+        {{/HeaderUpdate.AncestryProof}}
+        {{^HeaderUpdate.AncestryProof}}
+        ancestry_proof: None,
+        {{/HeaderUpdate.AncestryProof}}
+        execution_header: VersionedExecutionPayloadHeader::Deneb(deneb::ExecutionPayloadHeader {
+            parent_hash: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.ParentHash}}").into(),
+            fee_recipient: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.FeeRecipient}}").into(),
+            state_root: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.StateRoot}}").into(),
+            receipts_root: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.ReceiptsRoot}}").into(),
+            logs_bloom: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.LogsBloom}}").into(),
+            prev_randao: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.PrevRandao}}").into(),
+            block_number: {{HeaderUpdate.ExecutionHeader.Deneb.BlockNumber}},
+            gas_limit: {{HeaderUpdate.ExecutionHeader.Deneb.GasLimit}},
+            gas_used: {{HeaderUpdate.ExecutionHeader.Deneb.GasUsed}},
+            timestamp: {{HeaderUpdate.ExecutionHeader.Deneb.Timestamp}},
+            extra_data: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.ExtraData}}").into(),
+            base_fee_per_gas: U256::from({{HeaderUpdate.ExecutionHeader.Deneb.BaseFeePerGas}}u64),
+            block_hash: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.BlockHash}}").into(),
+            transactions_root: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.TransactionRoot}}").into(),
+            withdrawals_root: hex!("{{HeaderUpdate.ExecutionHeader.Deneb.WithdrawalsRoot}}").into(),
+            blob_gas_used: {{HeaderUpdate.ExecutionHeader.Deneb.BlobGasUsed}},
+            excess_blob_gas: {{HeaderUpdate.ExecutionHeader.Deneb.ExcessBlobGas}},
+        }),
+        execution_branch: vec![
+        {{#HeaderUpdate.ExecutionBranch}}
+            hex!("{{.}}").into(),
+        {{/HeaderUpdate.ExecutionBranch}}
+        ],
+    })
+}
diff --git a/bridges/snowbridge/templates/module-weight-template.hbs b/bridges/snowbridge/templates/module-weight-template.hbs
new file mode 100644
index 00000000000..5919a7cc7c1
--- /dev/null
+++ b/bridges/snowbridge/templates/module-weight-template.hbs
@@ -0,0 +1,74 @@
+{{header}}
+//! Autogenerated weights for `{{pallet}}`
+//!
+//! THIS FILE WAS AUTO-GENERATED USING THE SUBSTRATE BENCHMARK CLI VERSION {{version}}
+//! DATE: {{date}}, STEPS: `{{cmd.steps}}`, REPEAT: `{{cmd.repeat}}`, LOW RANGE: `{{cmd.lowest_range_values}}`, HIGH RANGE: `{{cmd.highest_range_values}}`
+//! WORST CASE MAP SIZE: `{{cmd.worst_case_map_values}}`
+//! HOSTNAME: `{{hostname}}`, CPU: `{{cpuname}}`
+//! WASM-EXECUTION: `{{cmd.wasm_execution}}`, CHAIN: `{{cmd.chain}}`, DB CACHE: `{{cmd.db_cache}}`
+
+// Executed Command:
+{{#each args as |arg|}}
+// {{arg}}
+{{/each}}
+
+#![cfg_attr(rustfmt, rustfmt_skip)]
+#![allow(unused_parens)]
+#![allow(unused_imports)]
+#![allow(missing_docs)]
+
+use frame_support::{traits::Get, weights::{Weight, constants::RocksDbWeight}};
+use core::marker::PhantomData;
+
+/// Weight functions needed for `{{pallet}}`.
+pub trait WeightInfo {
+	{{#each benchmarks as |benchmark|}}
+	fn {{benchmark.name~}}
+	(
+		{{~#each benchmark.components as |c| ~}}
+		{{c.name}}: u32, {{/each~}}
+	) -> Weight;
+	{{/each}}
+}
+
+// For backwards compatibility and tests.
+impl WeightInfo for () {
+	{{#each benchmarks as |benchmark|}}
+	{{#each benchmark.comments as |comment|}}
+	/// {{comment}}
+	{{/each}}
+	{{#each benchmark.component_ranges as |range|}}
+	/// The range of component `{{range.name}}` is `[{{range.min}}, {{range.max}}]`.
+	{{/each}}
+	fn {{benchmark.name~}}
+	(
+		{{~#each benchmark.components as |c| ~}}
+		{{~#if (not c.is_used)}}_{{/if}}{{c.name}}: u32, {{/each~}}
+	) -> Weight {
+		// Proof Size summary in bytes:
+		//  Measured:  `{{benchmark.base_recorded_proof_size}}{{#each benchmark.component_recorded_proof_size as |cp|}} + {{cp.name}} * ({{cp.slope}} ±{{underscore cp.error}}){{/each}}`
+		//  Estimated: `{{benchmark.base_calculated_proof_size}}{{#each benchmark.component_calculated_proof_size as |cp|}} + {{cp.name}} * ({{cp.slope}} ±{{underscore cp.error}}){{/each}}`
+		// Minimum execution time: {{underscore benchmark.min_execution_time}}_000 picoseconds.
+		Weight::from_parts({{underscore benchmark.base_weight}}, {{benchmark.base_calculated_proof_size}})
+			{{#each benchmark.component_weight as |cw|}}
+			// Standard Error: {{underscore cw.error}}
+			.saturating_add(Weight::from_parts({{underscore cw.slope}}, 0).saturating_mul({{cw.name}}.into()))
+			{{/each}}
+			{{#if (ne benchmark.base_reads "0")}}
+			.saturating_add(RocksDbWeight::get().reads({{benchmark.base_reads}}_u64))
+			{{/if}}
+			{{#each benchmark.component_reads as |cr|}}
+			.saturating_add(RocksDbWeight::get().reads(({{cr.slope}}_u64).saturating_mul({{cr.name}}.into())))
+			{{/each}}
+			{{#if (ne benchmark.base_writes "0")}}
+			.saturating_add(RocksDbWeight::get().writes({{benchmark.base_writes}}_u64))
+			{{/if}}
+			{{#each benchmark.component_writes as |cw|}}
+			.saturating_add(RocksDbWeight::get().writes(({{cw.slope}}_u64).saturating_mul({{cw.name}}.into())))
+			{{/each}}
+			{{#each benchmark.component_calculated_proof_size as |cp|}}
+			.saturating_add(Weight::from_parts(0, {{cp.slope}}).saturating_mul({{cp.name}}.into()))
+			{{/each}}
+	}
+	{{/each}}
+}
diff --git a/bridges/snowbridge/templates/register_token.mustache b/bridges/snowbridge/templates/register_token.mustache
new file mode 100644
index 00000000000..e8d35be42ec
--- /dev/null
+++ b/bridges/snowbridge/templates/register_token.mustache
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: Apache-2.0
+// SPDX-FileCopyrightText: 2023 Snowfork <hello@snowfork.com>
+// Generated, do not edit!
+// See ethereum client README.md for instructions to generate
+
+use crate::InboundQueueFixture;
+use hex_literal::hex;
+use snowbridge_beacon_primitives::CompactExecutionHeader;
+use snowbridge_core::inbound::{Log, Message, Proof};
+use sp_std::vec;
+
+pub fn make_register_token_message() -> InboundQueueFixture {
+    InboundQueueFixture {
+        execution_header: CompactExecutionHeader{
+            parent_hash: hex!("{{InboundMessageTest.ExecutionHeader.ParentHash}}").into(),
+            block_number: {{InboundMessageTest.ExecutionHeader.BlockNumber}},
+            state_root: hex!("{{InboundMessageTest.ExecutionHeader.StateRoot}}").into(),
+            receipts_root: hex!("{{InboundMessageTest.ExecutionHeader.ReceiptsRoot}}").into(),
+        },
+        message: Message {
+            event_log: 	Log {
+                address: hex!("{{InboundMessageTest.Message.EventLog.Address}}").into(),
+                topics: vec![
+                {{#InboundMessageTest.Message.EventLog.Topics}}
+                    hex!("{{.}}").into(),
+                {{/InboundMessageTest.Message.EventLog.Topics}}
+                ],
+                data: hex!("{{InboundMessageTest.Message.EventLog.Data}}").into(),
+            },
+            proof: Proof {
+                block_hash: hex!("{{InboundMessageTest.Message.Proof.BlockHash}}").into(),
+                tx_index: {{InboundMessageTest.Message.Proof.TxIndex}},
+                data: (vec![
+                {{#InboundMessageTest.Message.Proof.Data.Keys}}
+                    hex!("{{.}}").to_vec(),
+                {{/InboundMessageTest.Message.Proof.Data.Keys}}
+                ], vec![
+                {{#InboundMessageTest.Message.Proof.Data.Values}}
+                    hex!("{{.}}").to_vec(),
+                {{/InboundMessageTest.Message.Proof.Data.Values}}
+                ]),
+            },
+        },
+    }
+}
diff --git a/bridges/snowbridge/templates/send_token.mustache b/bridges/snowbridge/templates/send_token.mustache
new file mode 100644
index 00000000000..e104d2da279
--- /dev/null
+++ b/bridges/snowbridge/templates/send_token.mustache
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: Apache-2.0
+// SPDX-FileCopyrightText: 2023 Snowfork <hello@snowfork.com>
+// Generated, do not edit!
+// See ethereum client README.md for instructions to generate
+
+use crate::InboundQueueFixture;
+use hex_literal::hex;
+use snowbridge_beacon_primitives::CompactExecutionHeader;
+use snowbridge_core::inbound::{Log, Message, Proof};
+use sp_std::vec;
+
+pub fn make_send_token_message() -> InboundQueueFixture {
+    InboundQueueFixture {
+        execution_header: CompactExecutionHeader{
+            parent_hash: hex!("{{InboundMessageTest.ExecutionHeader.ParentHash}}").into(),
+            block_number: {{InboundMessageTest.ExecutionHeader.BlockNumber}},
+            state_root: hex!("{{InboundMessageTest.ExecutionHeader.StateRoot}}").into(),
+            receipts_root: hex!("{{InboundMessageTest.ExecutionHeader.ReceiptsRoot}}").into(),
+        },
+        message: Message {
+            event_log: 	Log {
+                address: hex!("{{InboundMessageTest.Message.EventLog.Address}}").into(),
+                topics: vec![
+                {{#InboundMessageTest.Message.EventLog.Topics}}
+                    hex!("{{.}}").into(),
+                {{/InboundMessageTest.Message.EventLog.Topics}}
+                ],
+                data: hex!("{{InboundMessageTest.Message.EventLog.Data}}").into(),
+            },
+            proof: Proof {
+                block_hash: hex!("{{InboundMessageTest.Message.Proof.BlockHash}}").into(),
+                tx_index: {{InboundMessageTest.Message.Proof.TxIndex}},
+                data: (vec![
+                {{#InboundMessageTest.Message.Proof.Data.Keys}}
+                    hex!("{{.}}").to_vec(),
+                {{/InboundMessageTest.Message.Proof.Data.Keys}}
+                ], vec![
+                {{#InboundMessageTest.Message.Proof.Data.Values}}
+                    hex!("{{.}}").to_vec(),
+                {{/InboundMessageTest.Message.Proof.Data.Values}}
+                ]),
+            },
+        },
+    }
+}
